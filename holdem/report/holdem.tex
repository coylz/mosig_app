\documentclass[11pt]{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}
\usepackage{amsmath}

%\usepackage{graphvizzz}

%\usepackage[usenames,dvipsnames]{pstricks}
%\usepackage{epsfig}
%\usepackage{pst-grad} % For gradients
%\usepackage{pst-plot} % For axes

\usepackage{enumitem}

\usepackage{framed}

%%%%%%
% Pour mise-en-forme des fichiers Ada
%
% voir exemple en fin de ce fichier.
%
% ATTENTION, requiert encoding utf-8 (voir 2ième "\lstset" ci-dessous)
 
\usepackage{listings}
%\lstset{
%  morekeywords={abort,abs,accept,access,all,and,array,at,begin,body,
%      case,constant,declare,delay,delta,digits,do,else,elsif,end,entry,
%      exception,exit,for,function,generic,goto,if,in,is,limited,loop,
%      mod,new,not,null,of,or,others,out,package,pragma,private,
%      procedure,raise,range,record,rem,renames,return,reverse,select,
%      separate,subtype,task,terminate,then,type,use,when,while,with,
%      xor,abstract,aliased,protected,requeue,tagged,until,printf},
%  sensitive=f,
%  morecomment=[l]--,
%  morestring=[d]",
%  showstringspaces=false,
%  basicstyle=\tiny\ttfamily,
%  keywordstyle=\bf\tiny,
%  commentstyle=\itshape\tiny,
%  stringstyle=\sf\tiny,
%  extendedchars=true,
%  columns=[c]fixed
%}
\usepackage{color}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{myblue}{rgb}{0,0,0.82}

\lstset{%
  morekeywords={abort,abs,accept,access,all,and,array,at,begin,body,
      case,constant,declare,delay,delta,digits,do,else,elsif,end,entry,
      exception,exit,for,function,generic,goto,if,in,is,limited,loop,
      mod,new,not,null,of,or,others,out,package,pragma,private,
      procedure,raise,range,record,rem,renames,return,reverse,select,
      separate,subtype,task,terminate,then,type,use,when,while,with,
      xor,abstract,aliased,protected,requeue,tagged,until,printf},
  basicstyle=\scriptsize\ttfamily,%
  commentstyle=\color{mygreen}\footnotesize\ttfamily,%
  frameround=trBL,
  frame=single,
  breaklines=true,
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny,
  numbersep=10pt,
  language=Java,
  morekeywords={Math},
  keywordstyle=\color{myblue}\bf
}

% CI-DESSOUS: conversion des caractères accentués UTF-8 
% en caractères TeX dans les listings...
\lstset{
  literate=%
  {À}{{\`A}}1 {Â}{{\^A}}1 {Ç}{{\c{C}}}1%
  {à}{{\`a}}1 {â}{{\^a}}1 {ç}{{\c{c}}}1%
  {É}{{\'E}}1 {È}{{\`E}}1 {Ê}{{\^E}}1 {Ë}{{\"E}}1% 
  {é}{{\'e}}1 {è}{{\`e}}1 {ê}{{\^e}}1 {ë}{{\"e}}1%
  {Ï}{{\"I}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1%
  {ï}{{\"i}}1 {î}{{\^i}}1 {ô}{{\^o}}1%
  {Ù}{{\`U}}1 {Û}{{\^U}}1 {Ü}{{\"U}}1%
  {ù}{{\`u}}1 {û}{{\^u}}1 {ü}{{\"u}}1%
}

%%%%%%%%%%
% TAILLE DES PAGES (A4 serré)

\setlength{\parindent}{20pt}
\setlength{\parskip}{1ex}
\setlength{\textwidth}{17cm}
%\setlength{\textwidth}{16cm}
\setlength{\textheight}{23cm}
\setlength{\oddsidemargin}{-.7cm}
\setlength{\evensidemargin}{-.7cm}
\setlength{\topmargin}{-.5in}

%%%%%%%%%%
% EN-TÊTES ET PIED DE PAGES

\pagestyle{fancyplain}
\renewcommand{\headrulewidth}{0pt}
\addtolength{\headheight}{1.6pt}
\addtolength{\headheight}{2.6pt}
\lfoot{}
\cfoot{}


%%%%%%%%%%
% titre du document

\title{Algorithms \\
	\textbf{``Hold'em for n00bs''}}

\author{Thanh Luan, Six Cyril, Vial Loïc \\
			Rouby Thomas, Marriott Richard\\
			Poupin Pierre} 

\date{7\up{th} of November 2014}


\begin{document}

\maketitle

\section{Introduction}
The game we are playing is quite simple : It is a turn based two-player game, using a line of cards : Each player can take either the left-most card or the right-most card.
The winner is the one who gets the highest value calculated by the sum of cards.
We assume that we play with a basic artificial intelligence, which always pick the highest valued card.

We will present several types of algorithms to win in most cases : a greedy one, a full-exploration one, and a dynamic one.

The greedy algorithm is simply what the IA does, we hope to win at the end, but we are not sure if we will succeed, whereas the full-exploration of space's method checks every combination of cards' picking, to find a solution in advance, and then we can apply it.
The dynamic programming algorithm is basically optimizations we made on the full exploration algorithm, to enhance the performances and lessen the costs in memory and time.

We will now present with more details those algorithms.


\section{The greedy algorithm}
\subsection{Explanation}

\subsection{Implementation of the game using greedy algorithm}
Let's take a deeper look at the game and his basic algorithm :
To prepare the game, we have to shuffle the cards, and display them in a one-dimension array.
Then, we have to design two strategies : ours, and the one that the computer/IA/sister will use : The last one simply chooses the highest valued card between the two availables.
Our strategy will be the algorithms we talked previously in the introduction.
Finally, the game consists only in the alternance of the two strategies of the player.
To simulate the fact that we pick a card, we use two indexes that represents the limits of the array of cards : Upon picking a card, we increment (decrement) the left (right) index if we chose the left (right) card. The game is finished when the last card is picked, that is to say when the indexes are equal.

\subsection{Implementation}
\begin{lstlisting}
int cards[52];

shuffle_deck()
	for i = 1 to 4
		for j = 1 to 13
			cards[(i-1)*13+j] = j + 1
	// Now shuffle cards
	for i = 1 to 52
		one = rand(0,51)
		two = rand(0,51)

		temp = cards[one]
		cards[one] = cards[two] // Swap cards at two randoom positions
		cards[two] = temp

int sister(int left, int right)
	if cards[left] > cards[right]
		return left
	
	return right


int strategy (int left, int right)
	if cards[left] > cards[right]
		return left

	return right


void play_game ()
	int left = 0
	int right = 51
	int my_total = 0
	int sis_total = 0
	bool my_turn = true

	while (left != right)
		if my_turn
			choice = strategy(left,right)
			my_total = my_total + cards[choice]
		else
			choice = sister(left,right)
			sis_total = sis_total + cards[choice]

		if choice == left
			left++
		else
			right--

		my_turn = !my_turn

	// Final Card
	if my_turn
		my_total = my_total + cards[left]
	else
		sis_total = sis_total + cards[left]
\end{lstlisting}

\subsection{Discussion}

\section{Full solution-space algorithm}
% Cyril's algorithm
\subsection{Explanation}
\subsection{Complexity, optimization}

\section{Dynamic implementation}
Starting with a full pack of cards, unless the final two cards are the left-most pair or the right-most pair, there is always more than one sequence of card selections that will lead to us having that final remaining pair. The recursive formula above therefore describes the problem as a ``linked tree'' (i.e. a triangular lattice where where the right and the left children of any two horizontally adjacent nodes are the same node) of subproblems where each subproblem is not unique. We argue that this recursive function will calculate the optimal score when provided with the appropriate base cases.


\footnotesize
\begin{align*}
	Best(i, j) = Max\left( 
	\left[C[i] +
	\begin{cases}
		Best(i+2,j) & \text{if $C[i+1] > C[j]$} \\
		Best(i+1,j-1) & \text{otherwise}
	\end{cases}
	\right]
	,
	\left[
	C[j] +
	\begin{cases}
		Best(i+1,j-1) & \text{if $C[i] > C[j-1]$} \\
		Best(i,j-2) & \text{otherwise}
	\end{cases}
\right]
	\right)
\end{align*}
\normalsize

\subsubsection*{Example}
	$\text{Cards } = \{5,7,9,1,4,2\}$

	\begin{tabular}[c]{cc|cccccc}
		& $i$ $\rightarrow$\\

		$j$          &   & 1 & 2 & 3 & 4 & 5 & 6 \\
		             \cline{2-8}
		$\downarrow$ & 1 & 5 & X & X & X & X & X \\
		             & 2 & 7 & 7 & X & X & X & X \\
		             & 3 &   & 9 & 9 & X & X & X \\
		             & 4 &   &   & 9 & 1 & X & X \\
		             & 5 & ? &   &   & 4 & 4 & X \\
		             & 6 & ? & ? &   &   & 4 & 2
		
	\end{tabular}

\subsection{Top-down}

\subsection{Bottom-up}
As each subproblem is not unique, a recursive algorithm is at risk of performing the same calculations multiple times. The recursive, top-down version of the solution described in this paper performs a check before calculating the values for a node to ensure they haven't been calculated before. In the bottom-up version of the solution, described here, we instead start with the base cases (along the primary diagonal and the adjacent diagonal of the array pictured above) and then cycle through each of the remaining cells only a single time.

From the recursive formula you can see that $Best(i, j)$ is always dependent on a cell two steps away, towards the top-right of the pictured
array: either $(i+2), (j-2)$ or $(i+1, j-1)$. i.e. To calculate the value of ``Best'' for any cell, the next diagonal is skipped and the 
dependencies are found in the following diagonal. If we were to assume that the primary player always goes first then these diagonals 
(corresponding to the problems with which the second player is faced) would not need to be calculated - 
they could be left blank. However, the optimal solution for a player does not necessarily require them to go first. It is 
then necessary to treat them as a game with one less card, where the second player has already taken one of the cards. 
In this case, the primary player is always left with a subproblem with an odd number of cards. He/she will then 
be left with the final card - the base case along the main diagonal. If the primary player goes first then he will always 
be left with the final two cards, of which he/she would want to take the largest. The base case for the 
second diagonal is therefore $Best(i-1, i) = MAX(cards[i-1], cards[i])$.

\subsubsection*{Algorithm Details}
\begin{itemize}
		\item The structure used for the nodes (the ``problem'' structure) contains the value of ``best'' as well as a pointer to the node that is the optimal ``subproblem'', therefore forming a linked list of optimal decisions.
		\item Despite the problem being a triangular array of nodes, for simplicity we represent is as a square 2D array. As this is just an array of pointers to ``problem'' structures, it wouldn't take up as much space as it could.
		\item Once the values of the nodes of the array have been calculated, the optimal scores for the cases where you go 
			first and when your sister goes first (and selects the maximum initial card) are compared. The global boolean variable, 	
			LET\_SISTER\_GO\_FIRST, is then set and the winning node returned by the function.
\end{itemize}


\section{Conclusion}





%	\digraph a {
%		size="3.5,3.5";
%		a->b;
%		a->c;
%		b->d;
%		b->e;
%		c->h;
%		c->i;
%		d->k;
%		e->k;
%		h->l;
%		i->l;
%		l->m;
%		k->m;
%	}
\end{document}
